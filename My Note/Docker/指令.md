
$ docker container stop CONTAINER ID  暫停容器



$ docker container list. 活躍中的容器
>
	CONTAINER ID                                                              c17cb28fdc5a
	IMAGE                映像檔名稱                                         nginx
	COMMAND       初始指令。                                         "/docker-entrypoint.…"       
	CREATED          啟動容器時間                                      3 minutes ago
	STATUS             容器的健康狀態                                  Up 3 minutes
	PORTS               指定的 port 對應位置.                        0.0.0.0:80->80/tcp
	NAMES.             容器的名字(由 Docker 隨機分配).     jolly_mcnulty


$ docker container list --all  列出所有包含被暫停的容器( STATUS  變成了 Exited 的狀態)

```
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS                      PORTS     NAMES
c17cb28fdc5a   nginx     "/docker-entrypoint.…"   17 minutes ago   Exited (0) 4 minutes ago              jolly_mcnulty
47cad9ca025e   nginx     "/docker-entrypoint.…"   30 minutes ago   Exited (0) 18 minutes ago             amazing_ishizaka
```


$ docker container start CONTAINER ID.  啟動已存在的容器


$ docker container run --name nginx --publish 80:80 --detach nginx 替容器命名

$ docker container logs  nginx  觀看容器的事件紀錄
$ docker container logs --follow nginx  觀看容器的事件紀錄(持續追蹤事件的進展)

$ docker container rm nginx 刪除容器
$ docker container rm --force nginx 強制刪除正在執行的容器


$ docker container run --interactive --tty nginx bash 進入另一個終端機

$ docker container run --detach --pulish 80:80    (nginx 讓 nginx 在背景執行
$ docker container *exec* --interactive --tty 64d52 bash 對正在運作中的容器下指令，都需要加入 `exec` 才能執行



# 建立自己的虛擬網路

```
$ docker network create APP  （名字自定義）e4ad3a30af60ff7ce3cf60758fb948b39c03db04... 
# 這邊和 Container 同理，是這個 network 的專屬 ID
```
```
$ docker network list 
NETWORK ID    NAME    DRIVER   SCOPE 
e4ad3a30af60  app     bridge   local 
8089a4c2e32a  bridge  bridge   local 
0df5a43ad470  host    host     local 
1ba8d9b1e033  none    null     local
```


因為 bridge 這個 driver 是 Docker 預設的虛擬網路 driver
如果不指定 driver 的話，就會使用 bridge 當作 driver，
使用 bridge 當作 driver 的虛擬網路通常適用在單主機的容器們需要互相溝通的時候；
另外一種 driver 叫做 overlay，這個虛擬網路是可以跨機器溝通的。



# 添加原先的容器到新的虛擬網路

```
$ docker container rm -f $(docker container ls -aq) 
# 我們先清除舊有的容器 

$ docker container run --detach --publish 80:80 --network app --name nginx nginx eb893a93e76abf6078eeab...

$ docker network inspect app
[
  ..
  "Containers": {
            "2d87882665ff11fc42cd6290bb8ae5b971cc89d5c44420b69fd45f4e49572f89": 
            {
                "Name": "nginx",
                "EndpointID": "85d0ab380efbf79e5e2f2d887ff9c83e956900bdf30c5a4a9d38e120480d9c31",
                "MacAddress": "02:42:ac:12:00:02",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
  },
  ...
]

```



# 替正在運作的容器添加新的虛擬網路
```
# 開啟一個 postgres 的容器且讓他連接到預設的 bridge 虛擬網路
$ docker container run --detach --name pg --env POSTGRES_PASSWORD=mysecretpassword postgres # 不換行 b70adc2d760d90b1a05a4f78a42621da73b96dc7b...


# 對一個正在運作中的容器添加新的虛擬網路
$ docker network connect app pg 
# 沒有反應是正常的，這個指令不會有 response

# 驗證這個容器同時連接到兩個虛擬網路
$ docker container inspect pg

# 要斷開某個虛擬網路的連接
$ docker network disconnect app pg
# 沒有反應是正常的，這個指令不會有 response

$ docker container inspect pg


```



# DNS

DNS 系統可以透過容器的名字，可以讓容器們彼此溝通



# 映像檔 ( Docker Image )

Docker 執行容器時的說明書，並附上工具包的一個檔案

映像檔 本身是唯讀的，我們沒辦法更動映像檔內部的檔案系統

```
$ docker image inspect nginx 
[ ... 
	"ExposedPorts": { "80/tcp": {} }, 
	.... 
	"Env": [ 
		"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin...", 
		"NGINX_VERSION=1.23.1", 
		"NJS_VERSION=0.7.6", 
		"PKG_RELEASE=1~bullseye" 
	], 
	.... 
	"Cmd": [ 
		"/bin/sh", 
		"-c", 
		"#(nop) ", 
		"CMD [\"nginx\" \"-g\" \"daemon off;\"]" 
	], 
	.... 
	"Os": "linux", 
... ]
```

ExposedPorts：
	映像檔在建置的時候就已經設定好了只能開啟的 port，我們都不會去更動右邊的 port，是因為更動後會和映像檔設定的不同，導致服務失效
	
ENV ： 環境變數
	可以在建置映像檔時就放進去的變數，而容器啟動時內部就會有這些環境變數
	
CMD：初始指令
	預設是啟動 nginx 的服務
	
OS：作業系統
	執行在 Linux 的作業系統上，macOS 本身也是運行了一個迷你的虛擬機在執行 Docker，
	所以這邊看到的 OS 才不會是 macOS 而是 Linux

## 映像檔加上儲存庫的名稱
```
nginx:lastest # 服務的名稱:標籤


$ docker image list
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
postgres     latest    38da3d5fc5bf   4 hours ago   360MB
nginx        latest    b005e88565d7   7 hours ago   135MB
nginx        <none>    6405d9b26faf   2 weeks ago   135MB

> 左至右分別是儲存庫的名稱、標籤、映像檔的 ID、建立時間以及大小。
```

## 改變映像檔的名字
```
docker image tag nginx:lastest adam/nginx:latest
# 無反應是正常的

$ docker image list
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
postgres     latest    38da3d5fc5bf   4 hours ago   360MB
nginx        latest    b005e88565d7   7 hours ago   135MB
nginx        <none>    6405d9b26faf   2 weeks ago   135MB
adam/nginx   latest    b005e88565d7   5 days  ago   276MB

# 這邊的貼標籤並沒有對映像檔做任何的更動，
# 可以看到不論是建立時間還是 IMAGE ID 都是一模一樣的

$ docker image push adam/nginx:latest
# 將映像檔推到已經註冊好的 DockerHub
```

Ｑ 容器和虛擬機的差別





 Docker 的容器和我們本機並不在同一個網路內











# docker command not found
```
$ touch ~/.bash_profile

$ echo 'export PATH="/Applications/Docker.app/Contents/Resources/bin:$PATH"' >> ~/.bash_profile

$ source ~/.bash_profile

$ docker --version
> Docker version 23.0.5, build bc4487a
```
